#
# generate_results.py
#
import re
import sys
from pathlib import Path

# --- Configuration ---
EVALUATION_PRECISION = 50
OUTPUT_PRECISION = 36

def generate_golden_results(expressions_header_path: Path, output_header_path: Path):
    """
    Uses the best engine for each expression type and handles all
    of SymPy's special return values (NaN, oo, zoo).
    """
    print("--- Mexce Golden Results Generator (Final Hybrid Engine, Corrected) ---")

    try:
        # Import SymPy's singletons for NaN and infinities
        from sympy import sympify, Symbol, N, Rational, Float, oo, zoo, S
        from sympy.core.relational import Relational
        import numpy as np
    except ImportError:
        print("\nFATAL ERROR: SymPy and NumPy are required. Run: pip install sympy numpy\n")
        sys.exit(1)

    print(f"Reading expressions from: '{expressions_header_path}'")
    content = expressions_header_path.read_text(encoding='utf-8')
    expressions = re.findall(r'"(.*?)"', content, re.DOTALL)
    print(f"Found {len(expressions)} expressions.")

    # --- SETUP CONTEXTS ---
    var_names_sympy = ['a', 'b', 'c', 'x', 'y', 'z', 'w']
    symbols = {s: Symbol(s) for s in var_names_sympy}
    subs_map = {
        symbols['a']: Rational('1.1'), symbols['b']: Rational('2.2'), symbols['c']: Rational('3.3'),
        symbols['x']: Rational('4.4'), symbols['y']: Rational('5.5'), symbols['z']: Rational('6.6'),
        symbols['w']: Rational('7.7'), 'pi': N(np.pi, EVALUATION_PRECISION), 'e': N(np.e, EVALUATION_PRECISION)
    }
    sympy_safe_globals = {"__builtins__": None, "Rational": Rational, **symbols}
    numeric_literal_re = re.compile(r'\b(\d+\.?\d*|\.\d+)\b')
    def rational_repl(m): return f"Rational('{m.group(1)}')"
    
    numpy_context = {s: np.longdouble(v) for s, v in {'a': '1.1', 'b': '2.2', 'c': '3.3', 'x': '4.4', 'y': '5.5', 'z': '6.6', 'w': '7.7', 'pi': str(np.pi), 'e': str(np.e)}.items()}
    numpy_functions = {'sin': np.sin, 'cos': np.cos, 'tan': np.tan, 'sqrt': np.sqrt, 'abs': np.abs, 'log': np.log, 'ln': np.log, 'log10': np.log10, 'log2': np.log2}
    numpy_safe_globals = {"__builtins__":{}, "longdouble": np.longdouble, **numpy_context, **numpy_functions}

    # --- EVALUATE EXPRESSIONS ---
    golden_results = []
    
    for i, expr_str in enumerate(expressions):
        result = None
        python_expr = expr_str.replace('^', '**')

        if '<' in python_expr or '>' in python_expr:
            try:
                np_expr = numeric_literal_re.sub(r"longdouble('\1')", python_expr)
                bool_result = eval(np_expr, numpy_safe_globals)
                result = Float(1.0 if bool_result else 0.0)
            except Exception:
                result = S.NaN # Use SymPy's NaN
        else:
            try:
                rational_expr = numeric_literal_re.sub(rational_repl, python_expr)
                symbolic_expr = sympify(rational_expr, locals=sympy_safe_globals)
                substituted_expr = symbolic_expr.subs(subs_map)
                result = substituted_expr.evalf(n=EVALUATION_PRECISION, strict=False)
            except Exception:
                result = S.NaN # Use SymPy's NaN
                
        golden_results.append(result)

    print("Evaluation complete.")

    # --- GENERATE C++ HEADER ---
    print(f"Writing documented results to: '{output_header_path}'")
    finfo_double = np.finfo(np.float64)
    with output_header_path.open('w', encoding='utf-8') as f:
        f.write("//\n// GENERATED BY 'generate_results.py' - DO NOT EDIT\n//\n")
        f.write("// Engine: SymPy (Rational) with NumPy (Relational) Fallback.\n\n")

        f.write("#pragma once\n\n#include <cstddef>\n#include <cmath>\n\n")
        f.write("namespace mexce {\nnamespace benchmark_data {\n\n")
        f.write("static constexpr long double kGoldenResults[] = {\n")
        
        for res in golden_results:
            if res is S.NaN:
                f.write("    NAN,\n")
            elif res.is_infinite:
                is_negative = hasattr(res, 'is_positive') and res.is_positive is False
                f.write(f"    {'HUGE_VALL' if not is_negative else '-HUGE_VALL'},\n")
            else:
                result_ld = np.longdouble(str(res))
                if result_ld > finfo_double.max:
                    f.write("    HUGE_VALL,\n")
                elif result_ld < -finfo_double.max:
                    f.write("    -HUGE_VALL,\n")
                else:
                    formatted_val = np.format_float_scientific(result_ld, precision=OUTPUT_PRECISION, trim='-')
                    f.write(f"    {formatted_val}L,\n")
                
        f.write("};\n\n")
        f.write(f"constexpr std::size_t kGoldenResultsCount = {len(golden_results)};\n\n")
        f.write("}  // namespace benchmark_data\n}\n")
    
    print("Generation complete.")


if __name__ == "__main__":
    generate_golden_results(Path("benchmark_expressions.h"), Path("benchmark_results.h"))
